<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Basic Dictionary (sql.js)</title>
<style>
body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;}
.container{max-width:800px;margin:0 auto;}
h1{font-size:1.4rem;}
form{margin-top:12px;display:flex;gap:8px;}
input[type="text"]{flex:1;padding:8px;font-size:1rem;}
button{padding:8px 12px;font-size:1rem;}
#info{margin-top:12px;color:#666;}
#definition{margin-top:18px;padding:12px;border-radius:6px;background:#f8f8f8;border:1px solid #eee;white-space:pre-wrap;}
#error{margin-top:12px;color:#b00020;}
.meta{font-size:0.9rem;color:#444;margin-top:8px;}
.defH{margin:0;}
.defP{margin:0;}
</style>
</head>
<body>
<div class="container">
<h1>Basic Dictionary (sql.js + words.db)</h1>
<p>Type a word and press Search. This page loads <code>words.db</code> using sql.js in the browser — run it from a local or static server (e.g. <code>python -m http.server</code>).</p>
<form id="searchForm">
<input id="query" type="text" placeholder="Enter a word" autocomplete="off" required />
<button type="submit">Search</button>
</form>
<div id="info">Loading database...</div>
<div id="error" role="alert" aria-live="assertive"></div>
<div id="definition" aria-live="polite"></div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.js"></script>
<script>
(async function(){
  // Ensure initSqlJs is available (sql-wasm.js must load first - we include it above)
  const SQL = await initSqlJs({
    locateFile: file => 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.wasm'
  });

  const infoEl = document.getElementById('info');
  const errorEl = document.getElementById('error');
  const defEl = document.getElementById('definition');
  let db = null;

  try {
    infoEl.textContent = 'Fetching words.db...';
    const res = await fetch('words.db');
    if (!res.ok) throw new Error('Failed to fetch words.db: ' + res.status);
    const buffer = await res.arrayBuffer();
    db = new SQL.Database(new Uint8Array(buffer));
    infoEl.textContent = 'Database loaded.';
  } catch (e) {
    infoEl.textContent = '';
    errorEl.textContent = 'Error loading database: ' + e.message;
    console.error(e);
    return;
  }

  // Minimal search implementation tailored for a "words" table (word, type, definitions)
  const tableName = 'words';

  // prepare statements (case-insensitive) — fetch all matching rows (no LIMIT)
  const stmtExact = db.prepare(`SELECT word, type, definitions FROM "${tableName}" WHERE lower(word) = $w;`);
  const stmtLike  = db.prepare(`SELECT word, type, definitions FROM "${tableName}" WHERE lower(word) LIKE $p;`);

  function escapeHtml(str){
    if (str === null || str === undefined) return '';
    return String(str)
      .replace(/&/g, '&')
      .replace(/</g, '<')
      .replace(/>/g, '>')
      .replace(/"/g, '"')
      .replace(/'/g, '&#039;');
  }

  // Parse a definitions field into an array of definition strings.
  // Supports JSON arrays, newline-separated, semicolon-separated, and pipe-separated values.
  function parseDefinitions(text){
    if(text === null || text === undefined) return [];
    let s = String(text).trim();
    if(!s) return [];
    // Try JSON array first
    if((s.startsWith('[') || s.startsWith('{'))){
      try{
        const parsed = JSON.parse(s);
        if(Array.isArray(parsed)) return parsed.map(x=>x==null?'':String(x).trim()).filter(Boolean);
        if(typeof parsed === 'string') return [parsed.trim()];
      }catch(e){
        // fall through to splitting
      }
    }
    // Split on newlines, semicolons, or pipes
    const parts = s.split(/\r?\n|;|\|/).map(p=>p.trim()).filter(Boolean);
    return parts.length ? parts : [s];
  }

  function renderRows(rows){
    if(!rows || rows.length===0) return '<p class="defP">No definition found.</p>';
    return rows.map(row=>{
      const w = row['word'] || '';
      const t = row['type'] || '';
      const defs = parseDefinitions(row['definitions']);
      const title = t ? `${w} — ${t}` : `${w}`;
      const defsHtml = defs.length
        ? defs.map(d=>`<p class="defP">${escapeHtml(d)}</p>`).join('\n')
        : `<p>No definition available.</p>`;
      return `<h2 class="defH">${escapeHtml(title)}</h2>\n${defsHtml}`;
    }).join('\n<hr/>\n');
  }

  document.getElementById('searchForm').addEventListener('submit', function(e){
    e.preventDefault();
    errorEl.textContent = '';
    defEl.innerHTML = '';
    const q = document.getElementById('query').value.trim();
    if (!q) return;
    infoEl.textContent = 'Searching...';

    try {
      const rows = [];
      stmtExact.bind({$w: q.toLowerCase()});
      while(stmtExact.step()){
        rows.push(stmtExact.getAsObject());
      }
      stmtExact.reset();

      if(rows.length === 0){
        stmtLike.bind({$p: q.toLowerCase() + '%'});
        while(stmtLike.step()){
          rows.push(stmtLike.getAsObject());
        }
        stmtLike.reset();
      }

      defEl.innerHTML = renderRows(rows);
      infoEl.textContent = '';
      if(rows.length === 0) infoEl.textContent = '';
    } catch(err){
      console.error(err);
      errorEl.textContent = 'Search error: ' + err.message;
      infoEl.textContent = '';
    }
  });
})();
</script>
</body>
</html>